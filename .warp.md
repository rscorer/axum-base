# WARP AI Configuration - Axum Base

## Project Overview
This is a production-ready, modular Rust web server template built with Axum 0.7. It serves as a foundation for building secure, scalable web applications with authentication, database integration, and comprehensive testing.

## Tech Stack
- **Framework**: Axum 0.7 (async web framework)
- **Runtime**: Tokio (async runtime)
- **Database**: PostgreSQL with SQLx for type-safe queries
- **Authentication**: tower-sessions with Argon2 password hashing
- **Templating**: Tera template engine
- **Testing**: Comprehensive unit and integration tests
- **Edition**: Rust 2024

## Architecture & Module Structure
The codebase follows a modular design pattern:

```
src/
├── main.rs         # Application entry point
├── api.rs          # API route handlers and business logic
├── auth.rs         # Authentication middleware and utilities
├── context.rs      # Application context and shared state
├── database.rs     # Database connection and configuration
├── models.rs       # Data models and database schemas
├── routes.rs       # Route definitions and middleware setup
├── server.rs       # Server initialization and configuration
├── services.rs     # Business logic and service layer
└── web.rs          # Web handlers for HTML responses
```

## Coding Guidelines

### Rust Conventions
- Follow idiomatic Rust patterns and the 2024 edition standards
- Use `async/await` consistently for asynchronous operations
- Prefer `Result<T, E>` for error handling over panicking
- Use structured error types with appropriate context
- Implement `Debug`, `Clone`, `Serialize`/`Deserialize` traits where appropriate

### Database Patterns
- Use SQLx for all database interactions with compile-time checked queries
- Database migrations are in the `migrations/` directory
- All queries should be type-safe using SQLx macros (`sqlx::query!`, `sqlx::query_as!`)
- Use transactions for complex operations that require atomicity

### Authentication & Security
- All passwords are hashed using Argon2
- Session management via tower-sessions with PostgreSQL store
- Authentication middleware protects sensitive routes
- Always validate and sanitize user input

### Error Handling
- Use structured error types that implement `std::error::Error`
- Provide meaningful error messages to users
- Log errors appropriately for debugging
- Use `anyhow` or custom error types for complex error scenarios

### Testing
- Write unit tests for business logic in `services.rs`
- Integration tests in `tests/` directory
- Use `axum-test` for testing HTTP endpoints
- Mock external dependencies appropriately

## Database Schema
- Uses PostgreSQL with SQLx migrations
- Session storage integrated with tower-sessions
- User authentication with secure password hashing
- Extensible schema design for additional features

## Development Workflow
- Environment variables configured via `.env` (see `.env.example`)
- Database migrations run automatically on startup in development
- Hot reloading supported via cargo-watch
- Comprehensive Makefile for common tasks

## Key Dependencies
- `axum` (0.7) - Web framework
- `sqlx` (0.8) - Database toolkit
- `tokio` (1.0) - Async runtime
- `tower-sessions` (0.13) - Session management
- `tera` (1.19) - Template engine
- `argon2` (0.5) - Password hashing

## Best Practices
- Keep handlers lightweight, move business logic to services
- Use middleware for cross-cutting concerns (auth, logging, CORS)
- Maintain separation of concerns between API and web handlers
- Write descriptive error messages and documentation
- Follow RESTful API design principles
- Use proper HTTP status codes and response formats

## When Adding New Features
1. Add data models in `models.rs`
2. Implement business logic in `services.rs`
3. Create route handlers in `api.rs` or `web.rs`
4. Add routes in `routes.rs`
5. Write comprehensive tests
6. Update database migrations if schema changes are needed
