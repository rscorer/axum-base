# AI Context Documentation - Axum Base

## Project Purpose & Overview

**Axum Base** is a production-ready, modular Rust web server template designed to serve as a robust foundation for building secure, scalable web applications. This project demonstrates modern Rust web development best practices using the Axum 0.8 framework, with comprehensive authentication, database integration, templating, and testing capabilities.

### Key Value Propositions
- **Production-Ready**: Includes authentication, session management, and security best practices
- **Type-Safe**: Leverages SQLx for compile-time checked database queries
- **Modular Architecture**: Clear separation of concerns across dedicated modules  
- **Comprehensive Testing**: Unit and integration tests with proper mocking
- **Modern Stack**: Uses Rust 2024 edition with latest ecosystem libraries

## Technology Stack & Architectural Decisions

### Core Framework & Runtime
- **Axum 0.8**: Modern, ergonomic web framework built on Tokio
  - Chosen for its excellent type safety, performance, and ecosystem integration
  - Provides powerful middleware system for cross-cutting concerns
  - Excellent support for both JSON APIs and HTML responses

- **Tokio**: High-performance async runtime
  - Enables concurrent request handling with minimal resource overhead
  - Full feature set enabled for comprehensive async capabilities

### Database Layer
- **PostgreSQL**: Primary database with SQLx integration
  - Chosen for reliability, ACID compliance, and advanced features
  - SQLx provides compile-time checked queries preventing runtime SQL errors
  - Migration system ensures reproducible schema changes

- **SQLx 0.8**: Type-safe SQL toolkit
  - All queries must use `sqlx::query!` or `sqlx::query_as!` macros
  - Prevents SQL injection and ensures query correctness at compile time
  - Supports database connection pooling for optimal performance

### Authentication & Security
- **tower-sessions 0.13**: Session management with PostgreSQL store
  - Secure, server-side session storage
  - Automatic session cleanup and configurable expiration
  - Integration with Axum middleware stack

- **Argon2 0.5**: Password hashing
  - Industry-standard, memory-hard password hashing algorithm
  - Resistant to both time-memory trade-off and side-channel attacks
  - Configurable work factors for security tuning

### Templating & Frontend
- **Tera 1.19**: Template engine for HTML responses
  - Django/Jinja2-like syntax for familiar development experience
  - Safe by default with automatic HTML escaping
  - Support for template inheritance and macros

- **Tailwind CSS**: Utility-first CSS framework with standalone CLI
  - Development: `tw.sh` script for watch mode (auto-rebuild on changes)
  - Production: `tw-build.sh` script for one-time minified builds
  - Input source: `input.css` (imports Tailwind directives)
  - Output target: `static/style.css` (served by Axum static handler)
  - Template integration: Referenced in `templates/base.html`

### Development & Testing
- **Rust 2024 Edition**: Latest language features and improvements
- **axum-test 14.0**: Specialized testing utilities for Axum applications
- **tokio-test 0.4**: Testing utilities for async code
- **reqwest**: HTTP client for integration testing

## Module Architecture & Responsibilities

The project follows a clear modular design that promotes maintainability and testability:

### Core Modules
```
src/
├── main.rs         # Application entry point and initialization
├── server.rs       # Server startup, configuration, and graceful shutdown
├── context.rs      # Application-wide state and dependency injection
├── database.rs     # Database connection pooling and configuration
└── routes.rs       # Route registration and middleware composition
```

### Business Logic Modules
```
src/
├── models.rs       # Data structures and database schema definitions
├── services.rs     # Business logic layer (core application functionality)
├── api.rs          # JSON API handlers and responses
└── web.rs          # HTML handlers with Tera template integration
```

### Infrastructure Modules
```
src/
├── auth.rs         # Authentication middleware and session management
```

### Database & Migrations
```
migrations/
├── 0001_create_initial_schema.sql    # Initial database structure
├── 0002_seed_categories.sql          # Reference data seeding
└── 0003_seed_sample_items.sql        # Sample data for development
```

### Testing Structure
```
tests/
├── api_tests.rs    # Integration tests for JSON API endpoints
└── cli_tests.rs    # Tests for CLI utilities and tools
```

## Database Migration & Schema Management

### Migration Strategies
- **Sequential Migrations**: Numbered migration files ensure proper ordering
- **Idempotent Operations**: Migrations can be safely re-run without side effects  
- **Development Automation**: Migrations run automatically on application startup
- **Production Controls**: Manual migration execution recommended for production

### Schema Design Principles
- **Normalization**: Proper database normalization to reduce redundancy
- **Constraints**: Use database constraints to enforce data integrity
- **Indexing**: Strategic indexes for query performance optimization
- **Security**: Row-level security and proper permission management

## Testing Architecture & Selective Threading

### Optimized Testing Strategy
This project implements **selective test threading** for optimal performance while maintaining reliability:

- **Unit Tests**: Execute in parallel for maximum speed (no special attributes)
- **Database Tests**: Execute serially with `#[serial]` attribute to prevent race conditions
- **Performance Benefits**: 60-80% faster than full serialization while ensuring correctness
- **Dependencies**: Uses `serial_test` crate for selective synchronization

### Unit Testing (Parallel Execution)
- **Service Layer Focus**: Comprehensive testing of business logic in `services.rs`
- **No Database Interaction**: Pure logic tests that run independently
- **Mocking Strategy**: Mock external dependencies (database, HTTP clients)
- **Error Scenarios**: Test both success paths and error conditions
- **Fast Execution**: ~0.00s total time due to parallel processing

### Integration Testing (Serial Execution)
- **HTTP Endpoint Testing**: Use `axum-test` for end-to-end API testing with `#[serial]`
- **Database Integration**: Test database operations with real PostgreSQL
- **CLI Testing**: Command-line utility tests with database interactions
- **Authentication Flows**: Verify login, logout, and protected route access
- **Template Rendering**: Ensure HTML responses render correctly
- **Execution Time**: ~10-15s total (serial but necessary for database safety)

### Test Threading Guidelines
```rust
// Unit tests (parallel) - No special attributes
#[test]
fn test_business_logic() {
    // Pure logic tests - runs in parallel
}

// Integration tests (serial) - Always use #[serial]
use serial_test::serial;

#[tokio::test]
#[serial]  // REQUIRED for database tests
async fn test_api_endpoint() {
    let test_db = TestDatabase::new().await;
    test_db.cleanup().await;  // Ensure clean state
    // Database test logic...
    test_db.cleanup().await;  // Clean up after test
}
```

### Test Organization & File Structure
- **`src/models.rs` tests**: Unit tests (parallel) - Data validation, conversions
- **`tests/api_tests.rs`**: Integration tests (serial) - HTTP endpoints with database
- **`tests/cli_tests.rs`**: CLI tests (serial) - Command-line tools with database
- **Helper utilities**: Shared test setup and teardown functions
- **Database isolation**: Each test starts and ends with clean database state

### Performance Optimization
- **Selective Threading**: Best of both worlds approach
- **Unit Test Speed**: Parallel execution for fast feedback loops
- **Integration Test Safety**: Serial execution prevents database race conditions
- **Overall Improvement**: Significantly faster than traditional single-threaded testing

## Security Considerations & Best Practices

### Authentication Security
- **Password Security**: Argon2 hashing with appropriate work factors
- **Session Management**: Secure session tokens with proper expiration
- **CSRF Protection**: Built-in protection against cross-site request forgery
- **Input Validation**: All user input validated and sanitized

### Database Security
- **SQL Injection Prevention**: Compile-time checked queries prevent injection
- **Connection Security**: Encrypted database connections in production
- **Credential Management**: Environment-based configuration for secrets
- **Access Controls**: Least-privilege database user permissions

### Infrastructure Security
- **Environment Isolation**: Separate configurations for dev/staging/production
- **Logging Security**: No sensitive data in application logs
- **Error Handling**: Detailed errors for developers, safe errors for users
- **Dependencies**: Regular security updates for all dependencies

## Development Workflow & Tools

### Environment Setup
1. **Database**: Local PostgreSQL instance (recommended: `cruise_dev` database name)
2. **Environment**: Copy `.env.example` to `.env` and configure
3. **Dependencies**: `cargo build` to fetch and compile dependencies
4. **Migrations**: Automatic on first run, manual via `sqlx migrate run`

### Development Commands
- **Development Server**: `cargo run` (default port 3093)
- **Tailwind CSS Development**: `./tw.sh` for watch mode (run in separate terminal)
- **Tailwind CSS Production**: `./tw-build.sh` for minified one-time build
- **Testing**: `cargo test` for all tests, `cargo test --test api_tests` for specific
- **Database**: `cargo run --bin create_user` and `cargo run --bin set_password`
- **Formatting**: `cargo fmt` for code formatting
- **Linting**: `cargo clippy` for code quality checks

### Hot Reloading
- **cargo-watch**: `cargo watch -x run` for automatic rebuilds
- **Database Changes**: Restart required for new migrations
- **Template Changes**: Automatic reload in development mode

### Frontend Asset Pipeline
The project uses a streamlined asset build process for CSS styling:

#### Tailwind CSS Workflow
- **Input File**: `input.css` contains Tailwind import directive (`@import "tailwindcss";`)
- **Build Scripts**: 
  - `tw.sh` - Development script with `--watch` flag for auto-rebuilds
  - `tw-build.sh` - Production script with `--minify` flag for optimized output
- **Output File**: `static/style.css` served by Axum's static file handler
- **Template Integration**: CSS linked in `templates/base.html` via `/static/style.css`

#### Development Workflow
1. Run `./tw.sh` in a separate terminal for continuous CSS builds
2. Start Axum server with `cargo run` in main terminal
3. Tailwind monitors templates and rebuilds CSS when classes change
4. Browser receives updated CSS automatically (no manual refresh needed)

#### Production Workflow
1. Run `./tw-build.sh` once before deployment
2. Generates minified CSS with unused styles purged
3. Optimized for production deployment and caching

#### Makefile Integration
- `make tailwind-dev` - Alternative to `./tw.sh`
- `make tailwind-build` - Alternative to `./tw-build.sh`

## AI Configuration Files Reference

This project includes several AI tool configuration files to optimize the development experience:

### `.warp.md` (WARP AI)
- **Purpose**: Provides context and coding guidelines for WARP terminal AI
- **Focus**: Architecture overview, coding conventions, and best practices
- **Usage**: Automatically loaded by WARP for intelligent suggestions

### `.copilotignore` (GitHub Copilot)  
- **Purpose**: Excludes sensitive files from Copilot suggestions and context
- **Security**: Prevents exposure of environment variables, logs, and secrets
- **Scope**: Build artifacts, temporary files, and configuration data

### `.cursorrules` (Cursor AI)
- **Purpose**: Comprehensive coding standards and project conventions
- **Coverage**: Module structure, testing requirements, security guidelines
- **Integration**: Seamless integration with Cursor's AI pair programming

### `.aider.conf.yml` (Aider AI)
- **Purpose**: Optimizes Aider for pair programming with this codebase
- **Features**: Model selection, file exclusions, and custom instructions
- **Workflow**: Auto-commits, code quality checks, and context mapping

## Performance Optimization Guidelines

### Database Performance
- **Connection Pooling**: Configured via SQLx for optimal resource usage
- **Query Optimization**: Use EXPLAIN ANALYZE for query performance analysis
- **Index Strategy**: Create indexes for frequently queried columns
- **Batch Operations**: Prefer batch inserts/updates over individual operations

### Application Performance  
- **Async Efficiency**: Leverage Tokio's async capabilities throughout the stack
- **Memory Management**: Minimize allocations in hot paths
- **Caching Strategy**: Implement application-level caching where appropriate
- **Monitoring**: Include performance metrics and logging for production

### Production Considerations
- **Resource Limits**: Configure appropriate memory and CPU limits
- **Graceful Shutdown**: Proper cleanup of database connections and sessions
- **Health Checks**: Implement health check endpoints for load balancers
- **Error Recovery**: Robust error handling and automatic retry mechanisms

## Extension & Customization Guidelines

### Adding New Features
1. **Model Definition**: Add data structures to `models.rs`
2. **Business Logic**: Implement core functionality in `services.rs`  
3. **API Endpoints**: Create handlers in `api.rs` (JSON) or `web.rs` (HTML)
4. **Route Registration**: Add new routes in `routes.rs`
5. **Database Schema**: Create migration files for schema changes
6. **Testing**: Write comprehensive unit and integration tests

### Common Customization Patterns
- **Additional Authentication**: OAuth, JWT, or custom auth providers
- **API Versioning**: Implement versioned API endpoints
- **Background Jobs**: Add async job processing with tools like `tokio-cron-scheduler`
- **WebSocket Support**: Real-time communication via Axum's WebSocket support
- **File Uploads**: Secure file handling with size limits and validation

### Deployment Considerations
- **Containerization**: Docker support with multi-stage builds
- **Environment Variables**: Comprehensive configuration via environment
- **Database Migrations**: Production-safe migration strategies
- **Monitoring**: Application metrics and log aggregation
- **Security Hardening**: Production security checklist and configuration

This documentation serves as the authoritative source for understanding the Axum Base project architecture, design decisions, and development practices. It should be referenced by all AI tools and developers working with this codebase.
