# Gemini AI Configuration - Axum Base

## Project Overview for Google Gemini

**Axum Base** is a production-ready Rust web server template showcasing modern web development practices. This project serves as a foundational template for building secure, performant web applications using the Rust ecosystem's best tools and libraries.

### Core Technology Decisions

**Language & Edition**: Rust 2024 Edition
- Latest language features and improvements
- Enhanced async/await capabilities
- Improved error handling patterns
- Modern syntax and idioms

**Web Framework**: Axum 0.7 + Tokio
- High-performance async web framework
- Excellent type safety and compile-time guarantees
- Modular middleware system
- Built on the robust Tokio async runtime

**Database Stack**: PostgreSQL + SQLx
- Reliable, ACID-compliant relational database
- Compile-time checked SQL queries via SQLx macros
- Connection pooling for optimal resource management
- Type-safe database operations preventing runtime errors

**Authentication System**: tower-sessions + Argon2
- Secure session management with PostgreSQL backing store
- Industry-standard Argon2 password hashing
- Protection against timing attacks and password cracking
- Integrated with Axum's middleware system

**Template Engine**: Tera
- Django/Jinja2-inspired syntax for familiarity
- Safe HTML escaping by default
- Template inheritance and macro support
- Server-side rendering capabilities

## System Architecture

### Modular Structure Philosophy
The application follows a layered architecture with clear boundaries:

```
┌─────────────────────────────────────────────────┐
│                 HTTP Layer                      │
│  ┌─────────────┐              ┌─────────────┐   │
│  │   api.rs    │              │   web.rs    │   │
│  │ (JSON APIs) │              │(HTML Pages) │   │
│  └─────────────┘              └─────────────┘   │
└─────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────┐
│              Business Logic Layer               │
│  ┌─────────────────────────────────────────────┐ │
│  │              services.rs                    │ │
│  │        (Core Application Logic)             │ │
│  └─────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────┐
│               Data Access Layer                 │
│  ┌─────────────┐              ┌─────────────┐   │
│  │  models.rs  │              │database.rs  │   │
│  │ (Data Types)│              │(Connection) │   │
│  └─────────────┘              └─────────────┘   │
└─────────────────────────────────────────────────┘
```

### Module Responsibilities

**Entry Point & Configuration**
- `main.rs`: Application bootstrapping and environment setup
- `server.rs`: HTTP server initialization and graceful shutdown
- `context.rs`: Dependency injection and application state management
- `routes.rs`: Route registration and middleware pipeline configuration

**Request Handling**
- `api.rs`: RESTful JSON API endpoints with structured responses
- `web.rs`: HTML page handlers with Tera template integration
- `auth.rs`: Authentication middleware and session utilities

**Business Logic & Data**
- `services.rs`: Core business logic, validation, and complex operations
- `models.rs`: Data structures, DTOs, and database schema representations
- `database.rs`: Connection pool management and database configuration

## Development Guidelines for Gemini

### Code Generation Preferences

**Database Operations**
Always generate SQLx-based code with compile-time verification:

```rust
// ✅ PREFERRED: Type-safe with compile-time checking
pub async fn find_user_by_id(pool: &PgPool, user_id: Uuid) -> Result<User, sqlx::Error> {
    sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, password_hash, created_at, updated_at
        FROM users
        WHERE id = $1 AND deleted_at IS NULL
        "#,
        user_id
    )
    .fetch_one(pool)
    .await
}

// ❌ AVOID: Raw SQL strings or runtime-checked queries
// let query = format!("SELECT * FROM users WHERE id = '{}'", user_id);
```

**Error Handling Patterns**
Generate structured error types with proper context:

```rust
#[derive(Debug, thiserror::Error)]
pub enum UserServiceError {
    #[error("User with ID {id} not found")]
    NotFound { id: Uuid },
    
    #[error("Username '{username}' is already taken")]
    UsernameExists { username: String },
    
    #[error("Database operation failed: {source}")]
    Database {
        #[from]
        source: sqlx::Error,
    },
    
    #[error("Validation failed: {message}")]
    Validation { message: String },
}
```

**Authentication Implementation**
Always use secure patterns for authentication:

```rust
use argon2::{Argon2, PasswordHash, PasswordHasher, PasswordVerifier, password_hash::SaltString};
use tower_sessions::Session;

pub async fn hash_password(password: &str) -> Result<String, argon2::password_hash::Error> {
    let salt = SaltString::generate(&mut rand::thread_rng());
    let argon2 = Argon2::default();
    
    argon2
        .hash_password(password.as_bytes(), &salt)
        .map(|hash| hash.to_string())
}

pub async fn verify_password(password: &str, hash: &str) -> Result<bool, argon2::password_hash::Error> {
    let parsed_hash = PasswordHash::new(hash)?;
    let argon2 = Argon2::default();
    
    Ok(argon2.verify_password(password.as_bytes(), &parsed_hash).is_ok())
}
```

**Route Handler Structure**
Generate lightweight handlers that delegate to services:

```rust
pub async fn create_user_endpoint(
    State(app_ctx): State<AppContext>,
    Json(request): Json<CreateUserRequest>,
) -> Result<Json<UserResponse>, AppError> {
    // Input validation
    request.validate().map_err(AppError::ValidationError)?;
    
    // Delegate to service layer
    let user = user_service::create_user(&app_ctx.db, request)
        .await
        .map_err(AppError::UserService)?;
    
    // Return structured response
    Ok(Json(UserResponse {
        id: user.id,
        username: user.username,
        email: user.email,
        created_at: user.created_at,
    }))
}
```

### Testing Code Generation

**Unit Test Patterns**
Focus on testing business logic with proper mocking:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use sqlx::PgPool;
    use uuid::Uuid;

    #[sqlx::test]
    async fn test_create_user_success(pool: PgPool) -> sqlx::Result<()> {
        // Arrange
        let request = CreateUserRequest {
            username: "testuser".to_string(),
            email: "test@example.com".to_string(),
            password: "secure_password123".to_string(),
        };

        // Act
        let result = user_service::create_user(&pool, request).await;

        // Assert
        assert!(result.is_ok());
        let user = result.unwrap();
        assert_eq!(user.username, "testuser");
        assert_eq!(user.email, "test@example.com");
        
        Ok(())
    }
}
```

**Integration Test Patterns**
Use axum-test for HTTP endpoint testing:

```rust
#[tokio::test]
async fn test_user_creation_api() {
    let app = create_test_app().await;
    let server = TestServer::new(app).unwrap();
    
    let response = server
        .post("/api/users")
        .json(&json!({
            "username": "newuser",
            "email": "new@example.com",
            "password": "strong_password456"
        }))
        .await;
    
    response.assert_status(StatusCode::CREATED);
    
    let user: UserResponse = response.json();
    assert_eq!(user.username, "newuser");
    assert_eq!(user.email, "new@example.com");
}
```

### Security Implementation Guidelines

**Input Validation**
Always generate comprehensive validation:

```rust
use validator::{Validate, ValidationError};

#[derive(Debug, Deserialize, Validate)]
pub struct CreateUserRequest {
    #[validate(length(min = 3, max = 50, message = "Username must be 3-50 characters"))]
    #[validate(regex(path = "USERNAME_REGEX", message = "Username contains invalid characters"))]
    pub username: String,
    
    #[validate(email(message = "Invalid email format"))]
    pub email: String,
    
    #[validate(length(min = 8, message = "Password must be at least 8 characters"))]
    #[validate(custom(function = "validate_password_strength"))]
    pub password: String,
}

fn validate_password_strength(password: &str) -> Result<(), ValidationError> {
    let has_uppercase = password.chars().any(|c| c.is_uppercase());
    let has_lowercase = password.chars().any(|c| c.is_lowercase());
    let has_digit = password.chars().any(|c| c.is_numeric());
    
    if has_uppercase && has_lowercase && has_digit {
        Ok(())
    } else {
        Err(ValidationError::new("Password must contain uppercase, lowercase, and numeric characters"))
    }
}
```

**Session Security Configuration**
Generate secure session management:

```rust
pub fn create_session_layer(pool: PgPool) -> SessionManagerLayer<PostgresStore> {
    let session_store = PostgresStore::new(pool);
    
    SessionManagerLayer::new(session_store)
        .with_secure(true)  // HTTPS only in production
        .with_http_only(true)  // Prevent XSS access
        .with_same_site(SameSite::Strict)  // CSRF protection
        .with_expiry(Expiry::OnInactivity(Duration::from_secs(3600)))  // 1 hour
        .with_name("axum_session")
}
```

### Performance Optimization Guidelines

**Database Connection Management**
Generate efficient connection pool configurations:

```rust
pub async fn create_database_pool(database_url: &str) -> Result<PgPool, sqlx::Error> {
    PgPoolOptions::new()
        .max_connections(20)
        .min_connections(5)
        .acquire_timeout(Duration::from_secs(3))
        .idle_timeout(Duration::from_secs(600))
        .max_lifetime(Duration::from_secs(1800))
        .test_before_acquire(true)
        .connect(database_url)
        .await
}
```

**Async Best Practices**
Generate non-blocking, efficient async code:

```rust
// Concurrent operations where possible
pub async fn get_user_with_posts(pool: &PgPool, user_id: Uuid) -> Result<UserWithPosts, AppError> {
    let (user_result, posts_result) = tokio::join!(
        find_user_by_id(pool, user_id),
        find_posts_by_user_id(pool, user_id)
    );
    
    let user = user_result.map_err(AppError::Database)?;
    let posts = posts_result.map_err(AppError::Database)?;
    
    Ok(UserWithPosts { user, posts })
}
```

## Integration with Development Workflow

### Environment Setup
- Use `.env.example` as template for local configuration
- Database migrations execute automatically in development
- Connection string: `postgres://username:password@localhost:5432/axum_base_dev`

### Quality Assurance Commands
```bash
# Format code according to Rust standards
cargo fmt

# Comprehensive linting with Clippy
cargo clippy --all-targets --all-features -- -D warnings

# Run all tests including database tests
cargo test --all-features

# Check for security vulnerabilities
cargo audit

# Verify SQLx queries against database
cargo sqlx prepare
```

### Development Server
```bash
# Standard development server
cargo run

# Auto-reload during development
cargo watch -x run

# Create test users
cargo run --bin create_user

# Reset user passwords
cargo run --bin set_password
```

When generating code suggestions, Gemini should prioritize security, type safety, performance, and maintainability while following these established patterns and conventions.
