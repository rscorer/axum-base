# Gemini AI Configuration - Axum Base

## Project Overview for Google Gemini

**Axum Base** is a production-ready Rust web server template showcasing modern web development practices. This project serves as a foundational template for building secure, performant web applications using the Rust ecosystem's best tools and libraries.

### Core Technology Decisions

**Language & Edition**: Rust 2024 Edition
- Latest language features and improvements
- Enhanced async/await capabilities
- Improved error handling patterns
- Modern syntax and idioms

**Web Framework**: Axum 0.7 + Tokio
- High-performance async web framework
- Excellent type safety and compile-time guarantees
- Modular middleware system
- Built on the robust Tokio async runtime

**Database Stack**: PostgreSQL + SQLx
- Reliable, ACID-compliant relational database
- Compile-time checked SQL queries via SQLx macros
- Connection pooling for optimal resource management
- Type-safe database operations preventing runtime errors

**Authentication System**: tower-sessions + Argon2
- Secure session management with PostgreSQL backing store
- Industry-standard Argon2 password hashing
- Protection against timing attacks and password cracking
- Integrated with Axum's middleware system

**Template Engine**: Tera
- Django/Jinja2-inspired syntax for familiarity
- Safe HTML escaping by default
- Template inheritance and macro support
- Server-side rendering capabilities

## System Architecture

### Modular Structure Philosophy
The application follows a layered architecture with clear boundaries:

```
┌─────────────────────────────────────────────────┐
│                 HTTP Layer                      │
│  ┌─────────────┐              ┌─────────────┐   │
│  │   api.rs    │              │   web.rs    │   │
│  │ (JSON APIs) │              │(HTML Pages) │   │
│  └─────────────┘              └─────────────┘   │
└─────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────┐
│              Business Logic Layer               │
│  ┌─────────────────────────────────────────────┐ │
│  │              services.rs                    │ │
│  │        (Core Application Logic)             │ │
│  └─────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────┘
┌─────────────────────────────────────────────────┐
│               Data Access Layer                 │
│  ┌─────────────┐              ┌─────────────┐   │
│  │  models.rs  │              │database.rs  │   │
│  │ (Data Types)│              │(Connection) │   │
│  └─────────────┘              └─────────────┘   │
└─────────────────────────────────────────────────┘
```

### Module Responsibilities

**Entry Point & Configuration**
- `main.rs`: Application bootstrapping and environment setup
- `server.rs`: HTTP server initialization and graceful shutdown
- `context.rs`: Dependency injection and application state management
- `routes.rs`: Route registration and middleware pipeline configuration

**Request Handling**
- `api.rs`: RESTful JSON API endpoints with structured responses
- `web.rs`: HTML page handlers with Tera template integration
- `auth.rs`: Authentication middleware and session utilities

**Business Logic & Data**
- `services.rs`: Core business logic, validation, and complex operations
- `models.rs`: Data structures, DTOs, and database schema representations
- `database.rs`: Connection pool management and database configuration

## Development Guidelines for Gemini

### Code Generation Preferences

**Database Operations**
Always generate SQLx-based code with compile-time verification:

```rust
// ✅ PREFERRED: Type-safe with compile-time checking
pub async fn find_user_by_id(pool: &PgPool, user_id: Uuid) -> Result<User, sqlx::Error> {
    sqlx::query_as!(
        User,
        r#"
        SELECT id, username, email, password_hash, created_at, updated_at
        FROM users
        WHERE id = $1 AND deleted_at IS NULL
        "#,
        user_id
    )
    .fetch_one(pool)
    .await
}

// ❌ AVOID: Raw SQL strings or runtime-checked queries
// let query = format!("SELECT * FROM users WHERE id = '{}'", user_id);
```

**Error Handling Patterns**
Generate structured error types with proper context:

```rust
#[derive(Debug, thiserror::Error)]
pub enum UserServiceError {
    #[error("User with ID {id} not found")]
    NotFound { id: Uuid },
    
    #[error("Username '{username}' is already taken")]
    UsernameExists { username: String },
    
    #[error("Database operation failed: {source}")]
    Database {
        #[from]
        source: sqlx::Error,
    },
    
    #[error("Validation failed: {message}")]
    Validation { message: String },
}
```

**Authentication Implementation**
Always use secure patterns for authentication:

```rust
use argon2::{Argon2, PasswordHash, PasswordHasher, PasswordVerifier, password_hash::SaltString};
use tower_sessions::Session;

pub async fn hash_password(password: &str) -> Result<String, argon2::password_hash::Error> {
    let salt = SaltString::generate(&mut rand::thread_rng());
    let argon2 = Argon2::default();
    
    argon2
        .hash_password(password.as_bytes(), &salt)
        .map(|hash| hash.to_string())
}

pub async fn verify_password(password: &str, hash: &str) -> Result<bool, argon2::password_hash::Error> {
    let parsed_hash = PasswordHash::new(hash)?;
    let argon2 = Argon2::default();
    
    Ok(argon2.verify_password(password.as_bytes(), &parsed_hash).is_ok())
}
```

**Route Handler Structure**
Generate lightweight handlers that delegate to services:

```rust
pub async fn create_user_endpoint(
    State(app_ctx): State<AppContext>,
    Json(request): Json<CreateUserRequest>,
) -> Result<Json<UserResponse>, AppError> {
    // Input validation
    request.validate().map_err(AppError::ValidationError)?;
    
    // Delegate to service layer
    let user = user_service::create_user(&app_ctx.db, request)
        .await
        .map_err(AppError::UserService)?;
    
    // Return structured response
    Ok(Json(UserResponse {
        id: user.id,
        username: user.username,
        email: user.email,
        created_at: user.created_at,
    }))
}
```

### Testing Optimization & Selective Threading

**Performance-Optimized Testing Architecture**
This project implements **selective test threading** for optimal performance:

- **Unit Tests**: Execute in parallel for maximum speed
- **Database Tests**: Execute serially with `#[serial]` to prevent race conditions
- **Smart Dependencies**: Uses `serial_test` crate for selective synchronization
- **Performance Gain**: Significantly faster than full serialization while maintaining correctness

**Unit Test Patterns (Parallel Execution)**
Generate fast, isolated unit tests without special attributes:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    // Unit tests run in parallel - no database interaction
    #[test]
    fn test_user_validation() {
        let user = User {
            username: "test".to_string(),
            email: "test@example.com".to_string(),
            // ... other fields
        };
        
        assert!(user.is_valid());
        // Fast, parallel execution
    }
    
    #[test] 
    fn test_password_strength_validation() {
        assert!(validate_password_strength("weak").is_err());
        assert!(validate_password_strength("Strong123!").is_ok());
        // Pure logic - runs in parallel
    }
}
```

**Integration Test Patterns (Serial Execution)**
Always use `#[serial]` for database-dependent tests:

```rust
use serial_test::serial;

#[tokio::test]
#[serial]  // REQUIRED for database tests
async fn test_user_creation_api() {
    let test_db = TestDatabase::new().await;
    test_db.cleanup().await;  // Ensure clean state
    
    let server = TestServer::new(create_test_app_with_db(&test_db.pool)).unwrap();
    
    let response = server
        .post("/api/users")
        .json(&json!({
            "username": "newuser",
            "email": "new@example.com", 
            "password": "strong_password456"
        }))
        .await;
    
    response.assert_status(StatusCode::CREATED);
    
    // Verify database state
    let user_count: (i64,) = sqlx::query_as(
        "SELECT COUNT(*) FROM users WHERE username = $1"
    )
    .bind("newuser")
    .fetch_one(&test_db.pool)
    .await
    .unwrap();
    
    assert_eq!(user_count.0, 1);
    test_db.cleanup().await;  // Clean state for next test
}

#[tokio::test]
#[serial]  // ALWAYS for CLI tests
async fn test_create_user_cli() {
    let test_db = TestDatabase::new().await;
    test_db.cleanup().await;
    
    let output = Command::new("cargo")
        .args(&["run", "--bin", "create_user", "--", "cliuser", "cli@test.com", "pass123"])
        .env("DATABASE_URL", &test_db.connection_string)
        .output()
        .await
        .expect("Failed to execute command");
        
    assert!(output.status.success());
    test_db.cleanup().await;
}
```

**Test Categorization Guidelines**
Generate tests with appropriate attributes based on functionality:

- **`src/models.rs` tests**: Unit tests (parallel) - No `#[serial]` needed
- **`tests/api_tests.rs`**: Integration tests (serial) - Always use `#[serial]`
- **`tests/cli_tests.rs`**: CLI tests (serial) - Always use `#[serial]`
- **Database interactions**: Any test touching DB must use `#[serial]`

**Performance Metrics**
- Unit tests: ~0.00s execution time (parallel)
- Integration tests: ~10-15s total (serial but necessary for correctness)
- Overall improvement: 60-80% faster than full serialization

### Security Implementation Guidelines

**Input Validation**
Always generate comprehensive validation:

```rust
use validator::{Validate, ValidationError};

#[derive(Debug, Deserialize, Validate)]
pub struct CreateUserRequest {
    #[validate(length(min = 3, max = 50, message = "Username must be 3-50 characters"))]
    #[validate(regex(path = "USERNAME_REGEX", message = "Username contains invalid characters"))]
    pub username: String,
    
    #[validate(email(message = "Invalid email format"))]
    pub email: String,
    
    #[validate(length(min = 8, message = "Password must be at least 8 characters"))]
    #[validate(custom(function = "validate_password_strength"))]
    pub password: String,
}

fn validate_password_strength(password: &str) -> Result<(), ValidationError> {
    let has_uppercase = password.chars().any(|c| c.is_uppercase());
    let has_lowercase = password.chars().any(|c| c.is_lowercase());
    let has_digit = password.chars().any(|c| c.is_numeric());
    
    if has_uppercase && has_lowercase && has_digit {
        Ok(())
    } else {
        Err(ValidationError::new("Password must contain uppercase, lowercase, and numeric characters"))
    }
}
```

**Session Security Configuration**
Generate secure session management:

```rust
pub fn create_session_layer(pool: PgPool) -> SessionManagerLayer<PostgresStore> {
    let session_store = PostgresStore::new(pool);
    
    SessionManagerLayer::new(session_store)
        .with_secure(true)  // HTTPS only in production
        .with_http_only(true)  // Prevent XSS access
        .with_same_site(SameSite::Strict)  // CSRF protection
        .with_expiry(Expiry::OnInactivity(Duration::from_secs(3600)))  // 1 hour
        .with_name("axum_session")
}
```

### Performance Optimization Guidelines

**Database Connection Management**
Generate efficient connection pool configurations:

```rust
pub async fn create_database_pool(database_url: &str) -> Result<PgPool, sqlx::Error> {
    PgPoolOptions::new()
        .max_connections(20)
        .min_connections(5)
        .acquire_timeout(Duration::from_secs(3))
        .idle_timeout(Duration::from_secs(600))
        .max_lifetime(Duration::from_secs(1800))
        .test_before_acquire(true)
        .connect(database_url)
        .await
}
```

**Async Best Practices**
Generate non-blocking, efficient async code:

```rust
// Concurrent operations where possible
pub async fn get_user_with_posts(pool: &PgPool, user_id: Uuid) -> Result<UserWithPosts, AppError> {
    let (user_result, posts_result) = tokio::join!(
        find_user_by_id(pool, user_id),
        find_posts_by_user_id(pool, user_id)
    );
    
    let user = user_result.map_err(AppError::Database)?;
    let posts = posts_result.map_err(AppError::Database)?;
    
    Ok(UserWithPosts { user, posts })
}
```

## Integration with Development Workflow

### Environment Setup
- Use `.env.example` as template for local configuration
- Database migrations execute automatically in development
- Connection string: `postgres://username:password@localhost:5432/axum_base_dev`

### Quality Assurance Commands
```bash
# Format code according to Rust standards
cargo fmt

# Comprehensive linting with Clippy
cargo clippy --all-targets --all-features -- -D warnings

# Run all tests including database tests
cargo test --all-features

# Check for security vulnerabilities
cargo audit

# Verify SQLx queries against database
cargo sqlx prepare
```

### Development Server
```bash
# Standard development server
cargo run

# Auto-reload during development
cargo watch -x run

# Create test users
cargo run --bin create_user

# Reset user passwords
cargo run --bin set_password
```

When generating code suggestions, Gemini should prioritize security, type safety, performance, and maintainability while following these established patterns and conventions.
