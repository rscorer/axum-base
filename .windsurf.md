# Windsurf AI Configuration - Axum Base

## Project Overview for Windsurf
**Axum Base** - Modern Rust web server template with production-ready features

### Stack Summary
- **Rust 2024** with **Axum 0.7** web framework
- **PostgreSQL** database with **SQLx** type-safe queries
- **Authentication** via tower-sessions and Argon2 hashing
- **Templating** with Tera engine for HTML responses

## Coding Patterns & Preferences

### Database Operations
```rust
// PREFERRED: Type-safe SQLx macros
let user = sqlx::query_as!(User, "SELECT * FROM users WHERE id = $1", user_id)
    .fetch_one(&pool).await?;

// AVOID: Raw SQL strings or other database libraries
```

### Error Handling
```rust
// PREFERRED: Structured Result types
async fn get_user(id: Uuid) -> Result<User, AppError> {
    // Implementation with proper error propagation
}

// AVOID: Panicking or unwrapping in business logic
```

### Authentication Patterns
```rust
// PREFERRED: tower-sessions middleware
use tower_sessions::{Session, SessionManagerLayer};

// PREFERRED: Argon2 for password hashing
use argon2::{Argon2, PasswordHash, PasswordHasher, PasswordVerifier};
```

### Route Handler Structure
```rust
// PREFERRED: Lightweight handlers, logic in services
pub async fn create_item_handler(
    State(app_ctx): State<AppContext>,
    Json(payload): Json<CreateItemRequest>,
) -> Result<Json<ItemResponse>, AppError> {
    let item = services::create_item(&app_ctx.db, payload).await?;
    Ok(Json(ItemResponse::from(item)))
}
```

## Module Responsibilities

### `api.rs` - JSON API Handlers
- HTTP request/response handling for JSON endpoints
- Input validation and deserialization
- Response formatting and error handling
- **Keep lightweight** - delegate business logic to services

### `services.rs` - Business Logic
- Core application functionality and business rules
- Database operations using SQLx
- Complex data transformations
- **Most unit tests should focus here**

### `auth.rs` - Authentication
- Session management middleware
- Password hashing and verification
- Authentication helper functions
- Route protection utilities

### `models.rs` - Data Structures  
- Database schema representations
- Request/response DTOs
- Serialization/deserialization implementations
- Type definitions for the application

## Code Quality Expectations

### Testing
- **Unit tests**: Focus on `services.rs` business logic
- **Integration tests**: Use `axum-test` for HTTP endpoints
- **Coverage**: Test both success and error scenarios
- **Isolation**: Mock external dependencies appropriately

### Security
- **Never log** passwords, tokens, or sensitive data
- **Always validate** user input before processing
- **Use SQLx macros** to prevent SQL injection
- **Hash passwords** with Argon2, never store plaintext

### Performance
- **Use connection pooling** for database operations  
- **Leverage async/await** throughout the application
- **Minimize allocations** in performance-critical paths
- **Consider caching** for frequently accessed data

## Common Code Suggestions

### Database Connection
```rust
// Establish connection pool
let database_url = env::var("DATABASE_URL")?;
let pool = PgPoolOptions::new()
    .max_connections(20)
    .connect(&database_url).await?;
```

### Session Management
```rust
// Session middleware setup
let session_store = PostgresStore::new(pool.clone());
let session_layer = SessionManagerLayer::new(session_store)
    .with_secure(false) // Set to true in production
    .with_same_site(SameSite::Lax);
```

### Error Response Pattern
```rust
#[derive(Debug, Serialize)]
pub struct ErrorResponse {
    pub error: String,
    pub message: String,
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, error_response) = match self {
            AppError::NotFound => (
                StatusCode::NOT_FOUND,
                ErrorResponse {
                    error: "Not Found".to_string(),
                    message: "The requested resource was not found".to_string(),
                }
            ),
            // ... other error variants
        };
        
        (status, Json(error_response)).into_response()
    }
}
```

## Development Commands
- `cargo run` - Start development server (port 3093)
- `cargo test` - Run all tests
- `cargo fmt` - Format code
- `cargo clippy` - Lint code
- `cargo run --bin create_user` - Create new user CLI
- `cargo run --bin set_password` - Set user password CLI

## Files to Avoid Modifying
- `.env` files (environment configuration)
- `/target/` directory (build artifacts)  
- `Cargo.lock` (dependency lock file)
- `*.log` files (application logs)

This configuration helps Windsurf provide contextually aware suggestions that align with the project's architecture, security requirements, and coding standards.
