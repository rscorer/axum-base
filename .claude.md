# Claude AI Configuration - Axum Base

## Project Context for Claude

You are assisting with **Axum Base**, a production-ready Rust web server template designed for building secure, scalable web applications. This project demonstrates modern Rust development practices using the latest ecosystem libraries.

### Technology Stack Overview
- **Language**: Rust 2024 Edition (latest language features)
- **Web Framework**: Axum 0.7 with Tokio async runtime
- **Database**: PostgreSQL with SQLx for compile-time checked queries
- **Authentication**: tower-sessions with PostgreSQL store + Argon2 password hashing
- **Templating**: Tera template engine (Django/Jinja2-like syntax)
- **Testing**: Comprehensive suite with axum-test and tokio-test

## Architectural Philosophy

### Modular Design Principles
The codebase follows a clear separation of concerns across dedicated modules:

**Core Infrastructure**
- `main.rs` → Application entry point and initialization
- `server.rs` → Server startup, configuration, graceful shutdown
- `context.rs` → Application state and dependency injection
- `database.rs` → Connection pooling and database configuration
- `routes.rs` → Route registration and middleware composition

**Business Logic Layer**
- `models.rs` → Data structures and database schema definitions
- `services.rs` → Core business logic and application functionality
- `api.rs` → JSON API handlers and responses
- `web.rs` → HTML handlers with Tera template integration

**Security & Infrastructure**
- `auth.rs` → Authentication middleware and session management

### Database Architecture
- **Sequential migrations** in `migrations/` directory with proper versioning
- **Type-safe queries** using SQLx macros for compile-time verification
- **Connection pooling** for optimal resource utilization
- **Transaction support** for complex operations requiring atomicity

## Coding Standards & Best Practices

### Rust Language Conventions
- **Async/Await**: Use consistently throughout the application
- **Error Handling**: Prefer `Result<T, E>` over panicking, implement structured error types
- **Type Safety**: Leverage Rust's type system for compile-time guarantees
- **Memory Safety**: Follow Rust ownership principles, minimize unnecessary allocations
- **Documentation**: Write clear rustdoc comments for public APIs

### Database Interaction Patterns
```rust
// ALWAYS use SQLx macros for type safety
let user = sqlx::query_as!(
    User,
    "SELECT id, username, email, created_at FROM users WHERE id = $1",
    user_id
)
.fetch_one(&pool)
.await?;

// NEVER use raw SQL strings
// let query = format!("SELECT * FROM users WHERE id = {}", user_id); // ❌
```

### Authentication & Security Requirements
- **Password Security**: All passwords MUST be hashed using Argon2 with appropriate work factors
- **Session Management**: Use tower-sessions exclusively for session handling
- **Input Validation**: Always validate and sanitize user input before processing
- **Logging Security**: Never log sensitive information (passwords, tokens, session data)
- **SQL Injection Prevention**: SQLx compile-time checking prevents injection attacks

### Error Handling Patterns
```rust
// Structured error types with context
#[derive(Debug, thiserror::Error)]
pub enum AppError {
    #[error("User not found")]
    NotFound,
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),
    #[error("Authentication failed")]
    Unauthorized,
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, message) = match self {
            AppError::NotFound => (StatusCode::NOT_FOUND, "Resource not found"),
            AppError::Unauthorized => (StatusCode::UNAUTHORIZED, "Authentication required"),
            AppError::Database(_) => (StatusCode::INTERNAL_SERVER_ERROR, "Internal server error"),
        };
        (status, Json(json!({ "error": message }))).into_response()
    }
}
```

### Route Handler Architecture
```rust
// Keep handlers lightweight - delegate to services
pub async fn create_user_handler(
    State(app_ctx): State<AppContext>,
    Json(payload): Json<CreateUserRequest>,
) -> Result<Json<UserResponse>, AppError> {
    // Input validation
    payload.validate()?;
    
    // Delegate business logic to services
    let user = user_service::create_user(&app_ctx.db, payload).await?;
    
    // Return structured response
    Ok(Json(UserResponse::from(user)))
}
```

## Testing Strategy

### Unit Testing Focus Areas
- **Services Module**: Comprehensive testing of business logic
- **Model Validation**: Ensure data integrity and serialization correctness
- **Error Scenarios**: Test failure modes and edge cases
- **Authentication**: Verify password hashing and session management

### Integration Testing Approach
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use axum_test::TestServer;
    
    #[tokio::test]
    async fn test_user_creation_endpoint() {
        let server = TestServer::new(create_app()).unwrap();
        
        let response = server
            .post("/api/users")
            .json(&json!({
                "username": "testuser",
                "email": "test@example.com",
                "password": "secure_password123"
            }))
            .await;
            
        response.assert_status_ok();
        // Additional assertions...
    }
}
```

### Database Testing Patterns
- Use test databases with proper setup/teardown
- Mock external dependencies appropriately
- Test both successful operations and error conditions
- Verify database constraints and migrations

## Performance Considerations

### Async Programming Best Practices
- **Connection Pooling**: Configure appropriate pool sizes for concurrent connections
- **Non-blocking Operations**: Use async/await throughout the request lifecycle
- **Resource Management**: Properly handle connection cleanup and timeouts
- **Concurrent Request Handling**: Leverage Tokio's concurrent capabilities

### Optimization Guidelines
```rust
// Efficient database queries with connection pooling
let pool = PgPoolOptions::new()
    .max_connections(20)
    .acquire_timeout(Duration::from_secs(3))
    .connect(&database_url)
    .await?;

// Minimize allocations in hot paths
pub async fn get_users_summary(pool: &PgPool) -> Result<Vec<UserSummary>, sqlx::Error> {
    sqlx::query_as!(
        UserSummary,
        "SELECT id, username FROM users ORDER BY created_at DESC LIMIT 100"
    )
    .fetch_all(pool)
    .await
}
```

## Security Guidelines

### Input Validation Requirements
```rust
use validator::{Validate, ValidationError};

#[derive(Debug, Deserialize, Validate)]
pub struct CreateUserRequest {
    #[validate(length(min = 3, max = 50))]
    pub username: String,
    
    #[validate(email)]
    pub email: String,
    
    #[validate(length(min = 8))]
    pub password: String,
}
```

### Session Security Configuration
```rust
let session_layer = SessionManagerLayer::new(PostgresStore::new(pool.clone()))
    .with_secure(true)  // HTTPS only in production
    .with_http_only(true)  // Prevent XSS attacks
    .with_same_site(SameSite::Strict)  // CSRF protection
    .with_expiry(Expiry::OnInactivity(Duration::from_secs(3600)));
```

## Development Workflow Integration

### Environment Configuration
- Copy `.env.example` to `.env` for local development
- Database migrations run automatically in development mode
- Use `DATABASE_URL=postgres://user:pass@localhost:5432/axum_base_dev`

### Common Development Commands
```bash
# Development server (with auto-reload)
cargo watch -x run

# Comprehensive testing
cargo test --all-features

# Code quality checks
cargo fmt && cargo clippy

# Database operations
cargo run --bin create_user
cargo run --bin set_password
sqlx migrate run
```

### Production Deployment Considerations
- Enable all security features (HTTPS, secure cookies)
- Configure appropriate logging levels
- Set up health check endpoints
- Implement graceful shutdown handling
- Use environment-specific configuration

## When Suggesting Code Changes

### Priority Guidelines
1. **Security First**: Always consider security implications
2. **Type Safety**: Leverage Rust's type system for correctness
3. **Performance**: Consider async efficiency and resource usage
4. **Maintainability**: Follow established patterns and conventions
5. **Testing**: Include test cases for new functionality

### Code Generation Preferences
- Generate comprehensive error handling for all functions
- Include proper documentation comments
- Follow the established module structure
- Use SQLx macros for all database operations
- Implement proper input validation
- Include relevant unit and integration tests

This configuration ensures Claude provides suggestions that align with the project's production-ready standards, security requirements, and modern Rust development practices.
