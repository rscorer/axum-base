# Claude AI Configuration - Axum Base

## Project Context for Claude

You are assisting with **Axum Base**, a production-ready Rust web server template designed for building secure, scalable web applications. This project demonstrates modern Rust development practices using the latest ecosystem libraries.

### Technology Stack Overview
- **Language**: Rust 2024 Edition (latest language features)
- **Web Framework**: Axum 0.7 with Tokio async runtime
- **Database**: PostgreSQL with SQLx for compile-time checked queries
- **Authentication**: tower-sessions with PostgreSQL store + Argon2 password hashing
- **Templating**: Tera template engine (Django/Jinja2-like syntax)
- **Testing**: Comprehensive suite with axum-test and tokio-test

## Architectural Philosophy

### Modular Design Principles
The codebase follows a clear separation of concerns across dedicated modules:

**Core Infrastructure**
- `main.rs` → Application entry point and initialization
- `server.rs` → Server startup, configuration, graceful shutdown
- `context.rs` → Application state and dependency injection
- `database.rs` → Connection pooling and database configuration
- `routes.rs` → Route registration and middleware composition

**Business Logic Layer**
- `models.rs` → Data structures and database schema definitions
- `services.rs` → Core business logic and application functionality
- `api.rs` → JSON API handlers and responses
- `web.rs` → HTML handlers with Tera template integration

**Security & Infrastructure**
- `auth.rs` → Authentication middleware and session management

### Database Architecture
- **Sequential migrations** in `migrations/` directory with proper versioning
- **Type-safe queries** using SQLx macros for compile-time verification
- **Connection pooling** for optimal resource utilization
- **Transaction support** for complex operations requiring atomicity

## Coding Standards & Best Practices

### Rust Language Conventions
- **Async/Await**: Use consistently throughout the application
- **Error Handling**: Prefer `Result<T, E>` over panicking, implement structured error types
- **Type Safety**: Leverage Rust's type system for compile-time guarantees
- **Memory Safety**: Follow Rust ownership principles, minimize unnecessary allocations
- **Documentation**: Write clear rustdoc comments for public APIs

### Database Interaction Patterns
```rust
// ALWAYS use SQLx macros for type safety
let user = sqlx::query_as!(
    User,
    "SELECT id, username, email, created_at FROM users WHERE id = $1",
    user_id
)
.fetch_one(&pool)
.await?;

// NEVER use raw SQL strings
// let query = format!("SELECT * FROM users WHERE id = {}", user_id); // ❌
```

### Authentication & Security Requirements
- **Password Security**: All passwords MUST be hashed using Argon2 with appropriate work factors
- **Session Management**: Use tower-sessions exclusively for session handling
- **Input Validation**: Always validate and sanitize user input before processing
- **Logging Security**: Never log sensitive information (passwords, tokens, session data)
- **SQL Injection Prevention**: SQLx compile-time checking prevents injection attacks

### Error Handling Patterns
```rust
// Structured error types with context
#[derive(Debug, thiserror::Error)]
pub enum AppError {
    #[error("User not found")]
    NotFound,
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),
    #[error("Authentication failed")]
    Unauthorized,
}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        let (status, message) = match self {
            AppError::NotFound => (StatusCode::NOT_FOUND, "Resource not found"),
            AppError::Unauthorized => (StatusCode::UNAUTHORIZED, "Authentication required"),
            AppError::Database(_) => (StatusCode::INTERNAL_SERVER_ERROR, "Internal server error"),
        };
        (status, Json(json!({ "error": message }))).into_response()
    }
}
```

### Route Handler Architecture
```rust
// Keep handlers lightweight - delegate to services
pub async fn create_user_handler(
    State(app_ctx): State<AppContext>,
    Json(payload): Json<CreateUserRequest>,
) -> Result<Json<UserResponse>, AppError> {
    // Input validation
    payload.validate()?;
    
    // Delegate business logic to services
    let user = user_service::create_user(&app_ctx.db, payload).await?;
    
    // Return structured response
    Ok(Json(UserResponse::from(user)))
}
```

## Testing Strategy

### Selective Test Threading Architecture
This project uses **optimized selective threading** for maximum performance while maintaining reliability:

- **Unit Tests**: Execute in parallel for fast feedback loops
- **Database Tests**: Execute serially with `#[serial]` to prevent race conditions
- **Performance Benefit**: Best of both worlds - speed where safe, isolation where needed
- **Dependencies**: Uses `serial_test` crate for selective synchronization

### Unit Testing (Parallel Execution)
```rust
// Unit tests run in parallel - no special attributes needed
#[test]
fn test_user_response_conversion() {
    let user = User {
        id: 1,
        username: "testuser".to_string(),
        email: "test@example.com".to_string(),
        // ... other fields
    };
    
    let response: UserResponse = user.into();
    assert_eq!(response.username, "testuser");
    // No database interaction = safe parallel execution
}

#[test]
fn test_password_validation() {
    // Pure logic tests - run fast in parallel
    assert!(validate_password_strength("weak123").is_err());
    assert!(validate_password_strength("Strong123!@#").is_ok());
}
```

### Integration Testing (Serial Execution)
```rust
use serial_test::serial;

#[tokio::test]
#[serial]  // REQUIRED for database tests
async fn test_user_creation_endpoint() {
    let test_db = TestDatabase::new().await;
    test_db.cleanup().await;  // Ensure clean state
    
    let server = TestServer::new(create_app_with_db(&test_db.pool)).unwrap();
    
    let response = server
        .post("/api/users")
        .json(&json!({
            "username": "testuser",
            "email": "test@example.com",
            "password": "secure_password123"
        }))
        .await;
        
    response.assert_status_ok();
    
    // Verify database state
    let user_count: (i64,) = sqlx::query_as(
        "SELECT COUNT(*) FROM users WHERE username = $1"
    )
    .bind("testuser")
    .fetch_one(&test_db.pool)
    .await
    .unwrap();
    
    assert_eq!(user_count.0, 1);
    test_db.cleanup().await;  // Clean up after test
}

#[tokio::test]
#[serial]  // ALWAYS use #[serial] for CLI tests
async fn test_create_user_cli() {
    let test_db = TestDatabase::new().await;
    test_db.cleanup().await;
    
    // Test CLI binary execution
    let output = Command::new("cargo")
        .args(&["run", "--bin", "create_user", "--", "cliuser", "cli@test.com", "password123"])
        .env("DATABASE_URL", &test_db.connection_string)
        .output()
        .await
        .expect("Failed to execute command");
        
    assert!(output.status.success());
    test_db.cleanup().await;
}
```

### Test File Organization
- **`src/models.rs` tests**: Unit tests (parallel) - data validation, conversions
- **`tests/api_tests.rs`**: API integration tests (serial) - HTTP endpoints with database
- **`tests/cli_tests.rs`**: CLI integration tests (serial) - command-line tools with database

### Database Testing Best Practices
```rust
use sqlx::{PgPool, Postgres, Transaction};

struct TestDatabase {
    pool: PgPool,
}

impl TestDatabase {
    async fn new() -> Self {
        // Use test database URL
        let pool = PgPool::connect(&test_database_url()).await.unwrap();
        Self { pool }
    }
    
    async fn cleanup(&self) {
        // Clean all test data - ensures test isolation
        sqlx::query("TRUNCATE users, sessions, categories CASCADE")
            .execute(&self.pool)
            .await
            .unwrap();
    }
}

// Always use #[serial] for database interactions
#[tokio::test]
#[serial]
async fn test_database_operation() {
    let test_db = TestDatabase::new().await;
    test_db.cleanup().await;  // Start clean
    
    // Test logic here...
    
    test_db.cleanup().await;  // End clean
}
```

### Performance Implications
- **Unit Tests**: ~0.00s execution (parallel)
- **Integration Tests**: ~10-15s total (serial but necessary for database safety)
- **Overall**: Significantly faster than full serialization while maintaining correctness

## Performance Considerations

### Async Programming Best Practices
- **Connection Pooling**: Configure appropriate pool sizes for concurrent connections
- **Non-blocking Operations**: Use async/await throughout the request lifecycle
- **Resource Management**: Properly handle connection cleanup and timeouts
- **Concurrent Request Handling**: Leverage Tokio's concurrent capabilities

### Optimization Guidelines
```rust
// Efficient database queries with connection pooling
let pool = PgPoolOptions::new()
    .max_connections(20)
    .acquire_timeout(Duration::from_secs(3))
    .connect(&database_url)
    .await?;

// Minimize allocations in hot paths
pub async fn get_users_summary(pool: &PgPool) -> Result<Vec<UserSummary>, sqlx::Error> {
    sqlx::query_as!(
        UserSummary,
        "SELECT id, username FROM users ORDER BY created_at DESC LIMIT 100"
    )
    .fetch_all(pool)
    .await
}
```

## Security Guidelines

### Input Validation Requirements
```rust
use validator::{Validate, ValidationError};

#[derive(Debug, Deserialize, Validate)]
pub struct CreateUserRequest {
    #[validate(length(min = 3, max = 50))]
    pub username: String,
    
    #[validate(email)]
    pub email: String,
    
    #[validate(length(min = 8))]
    pub password: String,
}
```

### Session Security Configuration
```rust
let session_layer = SessionManagerLayer::new(PostgresStore::new(pool.clone()))
    .with_secure(true)  // HTTPS only in production
    .with_http_only(true)  // Prevent XSS attacks
    .with_same_site(SameSite::Strict)  // CSRF protection
    .with_expiry(Expiry::OnInactivity(Duration::from_secs(3600)));
```

## Development Workflow Integration

### Environment Configuration
- Copy `.env.example` to `.env` for local development
- Database migrations run automatically in development mode
- Use `DATABASE_URL=postgres://user:pass@localhost:5432/axum_base_dev`

### Common Development Commands
```bash
# Development server (with auto-reload)
cargo watch -x run

# Comprehensive testing
cargo test --all-features

# Code quality checks
cargo fmt && cargo clippy

# Database operations
cargo run --bin create_user
cargo run --bin set_password
sqlx migrate run
```

### Production Deployment Considerations
- Enable all security features (HTTPS, secure cookies)
- Configure appropriate logging levels
- Set up health check endpoints
- Implement graceful shutdown handling
- Use environment-specific configuration

## When Suggesting Code Changes

### Priority Guidelines
1. **Security First**: Always consider security implications
2. **Type Safety**: Leverage Rust's type system for correctness
3. **Performance**: Consider async efficiency and resource usage
4. **Maintainability**: Follow established patterns and conventions
5. **Testing**: Include test cases for new functionality

### Code Generation Preferences
- Generate comprehensive error handling for all functions
- Include proper documentation comments
- Follow the established module structure
- Use SQLx macros for all database operations
- Implement proper input validation
- Include relevant unit and integration tests

This configuration ensures Claude provides suggestions that align with the project's production-ready standards, security requirements, and modern Rust development practices.
